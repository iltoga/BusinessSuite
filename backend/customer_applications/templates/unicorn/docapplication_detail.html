{% load filters %}

<div>
  <div>
    <div class="card">
      <div class="card-header bg-primary text-white">
        <h3>(#{{ docapplication.pk }}) {{ docapplication.product.name }} Application - {{ docapplication.customer.full_name }}</h3>
      </div>
      <table class="table">
        <tbody>
          <tr>
            <th scope="row" class="text-start">Application Type</th>
            <td class="text-start">{{ docapplication.get_application_type_display }}</td>
          </tr>
          <tr>
            <th scope="row" class="text-start">Customer</th>
            <td class="text-start">{{ docapplication.customer.full_name }}</td>
          </tr>
          <tr>
            <th scope="row" class="text-start">Product</th>
            <td class="text-start">{{ docapplication.product.name }}</td>
          </tr>
          <tr>
            <th scope="row" class="text-start">Application Date</th>
            <td class="text-start">{{ docapplication.doc_date }}</td>
          </tr>
          <tr>
            <th scope="row" class="text-start">Due Date</th>
            <td class="text-start">{{ docapplication.due_date }}</td>
          </tr>
          <tr>
            <th scope="row" class="text-start">Application Status</th>
            <td class="text-start">{% include "components/model_status_badge.html" with status=docapplication.status %}</td>
          </tr>
          {% if docapplication.notes %}
          <tr>
            <th scope="row" class="text-start">Notes</th>
            <td class="text-start">{{ docapplication.notes }}</td>
          </tr>
          {% endif %}</tbody>
      </table>

      {% with docapplication.get_completed_documents as uploaded_documents %}
        {% if uploaded_documents %}
          <h3 class="text-center my-4">Uploaded Documents</h3>

          <!-- Merge Documents Controls -->
          <div class="d-flex justify-content-between align-items-center mx-3 mb-3">
            <div>
              <span id="selected-count" class="text-muted">0 documents selected</span>
              <br><small class="text-muted"><i class="bi bi-grip-vertical"></i> Drag rows to set merge order</small>
            </div>
            <div class="btn-group" role="group">
              <button type="button" class="btn btn-outline-secondary btn-sm" id="btn-select-all-docs">
                <i class="bi bi-check-square"></i> Select All
              </button>
              <button type="button" class="btn btn-outline-secondary btn-sm" id="btn-deselect-all-docs">
                <i class="bi bi-square"></i> Deselect All
              </button>
              <button type="button" class="btn btn-info btn-sm" id="btn-merge-download" disabled>
                <i class="bi bi-file-earmark-pdf"></i> Merge & Download PDF
              </button>
            </div>
          </div>

          {% include "customer_applications/_documents_table.html" with documents=uploaded_documents docapplication=docapplication btn_update_text="Update" show_merge_checkboxes=True %}
        {% endif %}
      {% endwith %}

      {% get_incomplete_documents docapplication "required" as incomplete_required_docs %}
      {% if incomplete_required_docs %}
        <h3 class="text-center my-4">Required Documents</h3>
        {% include "customer_applications/_documents_table.html" with documents=incomplete_required_docs docapplication=docapplication %}
      {% endif %}

      {% get_incomplete_documents docapplication "optional" as incomplete_optional_docs %}
      {% if incomplete_optional_docs %}
        <h3 class="text-center my-4">Other Documents to Upload</h3>
        {% include "customer_applications/_documents_table.html" with documents=incomplete_optional_docs docapplication=docapplication upload_after_app_completed=True %}
      {% endif %}

      {% if docapplication.workflows.all|length > 0 %}
        <h3 class="my-4">Application Workflow (Tasks)</h3>
      {% endif %}
      {% include "customer_applications/_doc_workflow_table.html" with docapplication=docapplication %}

      {% include "components/audit_card.html" with model=docapplication perm='customer_applications,docapplication,can_audit' %}

      <div class="card-footer text-muted">
        <!-- <a href="{% url 'customer-application-list' %}" class="btn btn-outline-primary">Back</a> -->
        <a href="javascript:history.back()" class="btn btn-outline-primary">Back</a>
      </div>
    </div>
  </div>

<!-- Hidden form for merge download -->
<form id="merge-download-form" method="POST" action="{% url 'customer-application-documents-merge' %}" style="display: none;">
  {% csrf_token %}
</form>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const mergeForm = document.getElementById('merge-download-form');
    const mergeBtn = document.getElementById('btn-merge-download');
    const selectAllBtn = document.getElementById('btn-select-all-docs');
    const deselectAllBtn = document.getElementById('btn-deselect-all-docs');
    const selectedCountSpan = document.getElementById('selected-count');
    const mergeTable = document.getElementById('merge-documents-table');

    // Function to update the selected count and button state
    function updateSelectionState() {
        const checkboxes = document.querySelectorAll('.doc-merge-checkbox:checked');
        const count = checkboxes.length;

        if (selectedCountSpan) {
            selectedCountSpan.textContent = count + ' document' + (count !== 1 ? 's' : '') + ' selected';
        }

        if (mergeBtn) {
            mergeBtn.disabled = count === 0;
        }
    }

    // Function to update order numbers after drag
    function updateOrderNumbers() {
        document.querySelectorAll('.merge-doc-row').forEach(function(row, index) {
            const orderSpan = row.querySelector('.merge-order-number');
            if (orderSpan) {
                orderSpan.textContent = index + 1;
            }
        });
    }

    // Drag and drop functionality
    if (mergeTable) {
        const tbody = mergeTable.querySelector('tbody');
        let draggedRow = null;

        tbody.addEventListener('dragstart', function(e) {
            if (e.target.classList.contains('merge-doc-row')) {
                draggedRow = e.target;
                e.target.style.opacity = '0.5';
                e.dataTransfer.effectAllowed = 'move';
            }
        });

        tbody.addEventListener('dragend', function(e) {
            if (e.target.classList.contains('merge-doc-row')) {
                e.target.style.opacity = '1';
                draggedRow = null;
                // Remove all drag-over styles
                document.querySelectorAll('.merge-doc-row').forEach(function(row) {
                    row.classList.remove('drag-over');
                });
                updateOrderNumbers();
            }
        });

        tbody.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const targetRow = e.target.closest('.merge-doc-row');
            if (targetRow && targetRow !== draggedRow) {
                // Remove drag-over from all rows
                document.querySelectorAll('.merge-doc-row').forEach(function(row) {
                    row.classList.remove('drag-over');
                });
                targetRow.classList.add('drag-over');
            }
        });

        tbody.addEventListener('drop', function(e) {
            e.preventDefault();
            const targetRow = e.target.closest('.merge-doc-row');
            if (targetRow && draggedRow && targetRow !== draggedRow) {
                // Determine if we should insert before or after
                const rect = targetRow.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                if (e.clientY < midpoint) {
                    tbody.insertBefore(draggedRow, targetRow);
                } else {
                    tbody.insertBefore(draggedRow, targetRow.nextSibling);
                }
            }
        });

        // Make rows draggable
        document.querySelectorAll('.merge-doc-row').forEach(function(row) {
            row.setAttribute('draggable', 'true');
        });
    }

    // Add event listeners to all checkboxes
    document.querySelectorAll('.doc-merge-checkbox').forEach(function(checkbox) {
        checkbox.addEventListener('change', updateSelectionState);
    });

    // Select All header checkbox
    document.querySelectorAll('.select-all-docs').forEach(function(selectAll) {
        selectAll.addEventListener('change', function() {
            const table = this.closest('table');
            const checkboxes = table.querySelectorAll('.doc-merge-checkbox');
            checkboxes.forEach(function(cb) {
                cb.checked = selectAll.checked;
            });
            updateSelectionState();
        });
    });

    // Select All button
    if (selectAllBtn) {
        selectAllBtn.addEventListener('click', function() {
            document.querySelectorAll('.doc-merge-checkbox').forEach(function(cb) {
                cb.checked = true;
            });
            document.querySelectorAll('.select-all-docs').forEach(function(cb) {
                cb.checked = true;
            });
            updateSelectionState();
        });
    }

    // Deselect All button
    if (deselectAllBtn) {
        deselectAllBtn.addEventListener('click', function() {
            document.querySelectorAll('.doc-merge-checkbox').forEach(function(cb) {
                cb.checked = false;
            });
            document.querySelectorAll('.select-all-docs').forEach(function(cb) {
                cb.checked = false;
            });
            updateSelectionState();
        });
    }

    // Merge & Download button
    if (mergeBtn && mergeForm) {
        mergeBtn.addEventListener('click', function() {
            // Get selected checkboxes in current row order (respects drag reordering)
            const orderedIds = [];
            document.querySelectorAll('.merge-doc-row').forEach(function(row) {
                const checkbox = row.querySelector('.doc-merge-checkbox:checked');
                if (checkbox) {
                    orderedIds.push(checkbox.value);
                }
            });

            if (orderedIds.length === 0) {
                alert('Please select at least one document to merge.');
                return;
            }

            // Show loading state
            mergeBtn.disabled = true;
            const originalText = mergeBtn.innerHTML;
            mergeBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Merging...';

            // Clear any existing hidden inputs
            mergeForm.querySelectorAll('input[name="document_ids[]"]').forEach(function(input) {
                input.remove();
            });

            // Add selected document IDs to form in the correct order
            orderedIds.forEach(function(id) {
                const input = document.createElement('input');
                input.type = 'hidden';
                input.name = 'document_ids[]';
                input.value = id;
                mergeForm.appendChild(input);
            });

            // Submit form via fetch to handle the file download
            const formData = new FormData(mergeForm);

            fetch(mergeForm.action, {
                method: 'POST',
                body: formData,
            })
            .then(function(response) {
                if (!response.ok) {
                    return response.json().then(function(data) {
                        throw new Error(data.error || 'Failed to merge documents');
                    });
                }
                // Get filename from Content-Disposition header
                const disposition = response.headers.get('Content-Disposition');
                let filename = 'merged_documents.pdf';
                if (disposition && disposition.indexOf('filename=') !== -1) {
                    const matches = disposition.match(/filename="?([^"]+)"?/);
                    if (matches && matches[1]) {
                        filename = matches[1];
                    }
                }
                return response.blob().then(function(blob) {
                    return { blob: blob, filename: filename };
                });
            })
            .then(function(result) {
                // Create download link and trigger download
                const url = window.URL.createObjectURL(result.blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = result.filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();
            })
            .catch(function(error) {
                alert('Error: ' + error.message);
            })
            .finally(function() {
                // Restore button state
                mergeBtn.disabled = false;
                mergeBtn.innerHTML = originalText;
                updateSelectionState();
            });
        });
    }

    // Initial state update
    updateSelectionState();
});
</script>

<style>
.merge-doc-row.drag-over {
    border-top: 2px solid #0d6efd;
}
.merge-doc-row[draggable="true"]:hover .drag-handle {
    color: #0d6efd;
}
.drag-handle:active {
    cursor: grabbing !important;
}
</style>
</div>
